NS(1)                                                                                      General Commands Manual                                                                                      NS(1)



NNAAMMEE
       ns - network simulator (version 2)

SSYYNNOOPPSSIISS
       nnss [ _f_i_l_e [ _a_r_g _a_r_g _._._.  ] ]


DDEESSCCRRIIPPTTIIOONN
       _n_s  is an event-driven network simulator.  An extensible simulation engine is implemented in C++ that uses MIT's Object Tool Command Language, OTcl (an object oriented version of Tcl) as the command
       and configuration interface.  A previous version of the simulator i.e. ns version 1 used the Tool Command Language, Tcl as the configuration language.  The current version still supports  simulation
       scripts written in Tcl meant for the ns version 1 simulator.

       This manual page documents some of the interfaces for ns.  For much more complete documentation, please see "ns Notes and Documentation" [13], available in the distribution and on the web.

       The  simulator  is  invoked via the _n_s interpreter, an extension of the vanilla _o_t_c_l_s_h command shell.  A simulation is defined by a OTcl script.  The scripts use the Simulator Class as the principal
       interface to the simulation engine.  Using the methods defined in this class, a network topology is defined, traffic sources and sinks are configured, the simulation is invoked, and  the  statistics
       are collected.  By building upon a fully functional language, arbitrary actions can be programmed into the configuration.

       The first step in the simulation is to acquire an instance of the Simulator class.  Instances of objects in classes are created and destroyed in ns using the _n_e_w and _d_e_l_e_t_e methods.  For example, an
       instance of the Simulator object is created by the following command:

            e.g. set ns [new Simulator]

       A network topology is realized using three primitive building blocks: nodes, links, and agents.  The Simulator class has methods to create/ configure each of these building blocks.  Nodes  are  cre‐
       ated with the _n_o_d_e Simulator method that automatically assigns an unique address to each node.  Links are created between nodes to form a network topology with the _s_i_m_p_l_e_x_-_l_i_n_k and _d_u_p_l_e_x_-_l_i_n_k meth‐
       ods that set up unidirectional and bidirectional links respectively.  Agents are the objects that actively drive the simulation.  _A_g_e_n_t_s can be thought of as the processes and/or transport  entities
       that  run on _n_o_d_e_s that may be end hosts or routers.  Traffic sources and sinks, dynamic routing modules and the various protocol modules are all examples of agents.  Agents are created by instanti‐
       ating objects in the subclass of class Agent i.e., _A_g_e_n_t_/_t_y_p_e where type specifies the nature of the agent.  For example, a TCP agent is created using the command:

            set tcp [new Agent/TCP]


       Once the agents are created, they are attached to nodes with the _a_t_t_a_c_h_-_a_g_e_n_t Simulator method.  Each agent is automatically assigned a port number unique across all agents on a given  node  (analo‐
       gous  to  a tcp or udp port).  Some types of agents may have sources attached to them while others may generate their own data.  For example, you can attach ``ftp'' and ``telnet'' sources to ``tcp''
       agents but ``constant bit-rate'' agents generate their own data.  Applications are attached to agents using the _a_t_t_a_c_h_-_a_p_p method.

       Each object has some configuration parameters associated with it that can be modified.  Configuration parameters are instance variables of  the  object.   These  parameters  are  initialized  during
       startup  to  default  values that can simply be read from the instance variables of the object.  For example, _$_t_c_p _s_e_t _w_i_n_d_o_w__ returns the default window size for the tcp object.  The default values
       for that object can be explicitly overridden by simple assignment either before a simulation begins, or dynamically, while the simulation is in progress.  For example the window-size for a  particu‐
       lar TCP session can be changed in the following manner.

            $tcp set window_ 25

       The default values for the configuration parameters of all the class objects subsequently created can also be changed by simple assignment.  For example, we can say

            Agent/TCP set window_ 30

       to make all future tcp agent creations default to a window size of 30.

       Events  are scheduled in ns using the _a_t Simulator method that allows OTcl procedures to be invoked at arbitrary points in simulation time.  These OTcl callbacks provide a flexible simulation mecha‐
       nism -- they can be used to start or stop sources, dump statistics, instantiate link failures, reconfigure the network topology etc.  The simulation is started via the _r_u_n method and continues until
       there  are  no more events to be processed.  At this time, the original invocation of the _r_u_n command returns and the Tcl script can exit or invoke another simulation run after possible reconfigura‐
       tion.  Alternatively, the simulation can be prematurely halted by invoking the _s_t_o_p command or by exiting the script with Tcl's standard _e_x_i_t command.

       Packets are forwarded along the shortest path route from a source to a destination, where the distance metric is the sum of costs of the links traversed from the source to the destination.  The cost
       of  a  link  is  1  by  default;  the distance metric is simply the hop count in this case.  The cost of a link can be changed with the _c_o_s_t Simulator method.  A static topology model is used as the
       default in ns in which the states of nodes/links do not change during the course of a simulation.  Network Dynamics could be specified using methods described in NETWORK  DYNAMICS  METHODS  section.
       Also  static  unicast routing is the default in which the routes are pre-computed over the entire topology once prior to starting the simulation.  Methods to enable and configure dynamic unicast and
       multicast routing are described in the UNICAST ROUTING METHODS and MULTICAST ROUTING METHODS sections respectively.



NNSS CCOOMMMMAANNDDSS
       This section describes the basic commands to create the building blocks of the simulation (i.e. the node, link and agent objects) and to run the simulation.

       The first step in running a simulation as stated before is to acquire an instance of the Simulator class that has methods to configure and run the simulation.  Throughout  this  section  the  object
       variable name $ns is used to imply a Simulator object.

       $$nnss nnooddee
              Create a new node object and return a handle to it.

       $$nnss aallll--nnooddeess--lliisstt
              Returns a list of all the node objects defined in the simulation.

       $$nnss ssiimmpplleexx--lliinnkk _n_o_d_e_1 _n_o_d_e_2 _b_w _d_e_l_a_y _t_y_p_e
              Create a new unidirectional link between _n_o_d_e_1 and _n_o_d_e_2 with bandwidth _b_w in bits per second and link propagation delay _d_e_l_a_y in seconds.  _n_o_d_e_1 and _n_o_d_e_2 must have already been created with
              the _n_o_d_e method.  _b_w and _d_e_l_a_y default to 1.5 Mbits/sec and 100 ms respectively.  The defaults can be changed by modifying the relevant configuration parameters of the DelayLink  Object  (see
              DELAYLINK  OBJECTS  section).   _n_o_d_e_1  and _n_o_d_e_2 must have already been created with the _n_o_d_e method.  The queuing discipline of the link is specified by _t_y_p_e_, which may be DDrrooppTTaaiill,, FFQQ,, SSFFQQ,,
              DDRRRR,, RREEDD,, CCBBQQ,, or CCBBQQ//WWRRRR..  A DropTail link is a simple FIFO queue which drops the last packet in the queue when the queue overflows.  A FQ link is for Fair Queuing (for details see [?]).   A
              SFQ  link  is for Stochastic Fair Queuing (for details see [?]).  A DRR link is for deficit round robin scheduling (for details see [9]).  A RED link is a random-early drop queue (for details
              see [2]).  A CBQ link is for class-based queuing using a packet-by-packet round-robin scheduler (for details see [3]).  A CBQ/WRR link is for class-based queuing with a weighted  round  robin
              scheduler.   If multicast routing is used links with interface labels are required.  Such links are created by setting Simulator NumberInterfaces_ variable to 1.  All the subsequently created
              links will have interface labels.  To disable creation of interfaces simply reset NumberInterfaces_ to 0 (this is the default).

       $$nnss dduupplleexx--lliinnkk _n_o_d_e_1 _n_o_d_e_2 _b_w _d_e_l_a_y _t_y_p_e
              Create a new bidirectional link between _n_o_d_e_1 and _n_o_d_e_2 with bandwidth _b_w in bits per second and link propagation delay _d_e_l_a_y in seconds.  _n_o_d_e_1 and _n_o_d_e_2 must have already been created  with
              the  _n_o_d_e  method.  _b_w and _d_e_l_a_y default to 1.5 Mbits/sec and 100 ms respectively.  The defaults can be changed by modifying the relevant configuration parameters of the DelayLink Object (see
              DELAYLINK OBJECTS section).  The queuing discipline of the link is specified by _t_y_p_e_, which may be DDrrooppTTaaiill,, FFQQ SSFFQQ,, DDRRRR,, RREEDD,, CCBBQQ,, or CCBBQQ//WWRRRR..  A DropTail link is a simple FIFO  queue  which
              drops  the  last  packet  in the queue when the queue overflows.  A FQ link is for Fair Queuing (for details see [?]).  A SFQ link is for Stochastic Fair Queuing (for details see [?]).  A DRR
              link is for deficit round robin scheduling (for details see [9]).  A RED link is a random-early drop queue (for details see [2]).  A CBQ link is for class-based  queuing  using  a  packet-by-
              packet round-robin scheduler (for details see [3]).  A CBQ/WRR link is for class-based queuing with a weighted round robin scheduler.  If multicast routing is used links with interface labels
              are required.  Such links are created by setting Simulator NumberInterfaces_ variable to 1.  All the subsequently created links will have interface labels.  To disable creation of  interfaces
              simply reset NumberInterfaces_ to 0 (this is the default).

       $$nnss lliinnkk _n_o_d_e_1 _n_o_d_e_2
              Returns a reference to the link connecting nodes _n_o_d_e_1 and _n_o_d_e_2_.  This is useful for setting link configuration parameters and to invoke tracing methods (see LINK OBJECTS section).

       $$nnss qquueeuuee--lliimmiitt _n_o_d_e_1 _n_o_d_e_2 _q_u_e_u_e_-_l_i_m_i_t
              Set the maximum number of packets that can be queued on the link in the direction from _n_o_d_e_1 to _n_o_d_e_2 to _q_u_e_u_e_-_l_i_m_i_t_.  The link between node1 and node2 should have already been created.

       $$nnss ddeellaayy _n_o_d_e_1 _n_o_d_e_2 _t_i_m_e_-_i_n_t_e_r_v_a_l
              Set the latency of the link in the direction from _n_o_d_e_1 to _n_o_d_e_2 to _t_i_m_e_-_i_n_t_e_r_v_a_l seconds.  The link between node1 and node2 should have already been created.

       $$nnss ccoosstt  _n_o_d_e_1 _n_o_d_e_2 _c_o_s_t_-_v_a_l
              Assign the cost _c_o_s_t_-_v_a_l to the link between nodes _n_o_d_e_1 and _n_o_d_e_2_.  The costs assigned to links are used in unicast route computations.  All the links default to a cost of 1.

       $$nnss mmuullttii--lliinnkk _n_o_d_e_-_l_i_s_t _b_w _d_e_l_a_y _t_y_p_e
              Connects  the nodes specified in _n_o_d_e_-_l_i_s_t by a mesh of duplex links (to simulate a broadcast LAN) with bandwidth _b_w in bits per second and link propagation delay _d_e_l_a_y in seconds.  _n_o_d_e_-_l_i_s_t
              is a list of node object handles that have already been created with the _n_o_d_e method.  _b_w and _d_e_l_a_y default to 1.5 Mbits/sec and 100 ms respectively.  The defaults can be changed by modifying
              the  relevant  configuration  parameters of the DelayLink Object (see DELAYLINK OBJECTS section).  The queuing discipline of the link is specified by _t_y_p_e_, which may be DDrrooppTTaaiill,, FFQQ SSFFQQ,, DDRRRR,,
              RREEDD,, CCBBQQ,, or CCBBQQ//WWRRRR..  A DropTail link is a simple FIFO queue which drops the last packet in the queue when the queue overflows.  A FQ link is for Fair Queuing (for details see [?]).   A  SFQ
              link  is  for Stochastic Fair Queuing (for details see [?]).  A DRR link is for deficit round robin scheduling (for details see [9]).  A RED link is a random-early drop queue (for details see
              [2]).  A CBQ link is for class-based queuing using a packet-by-packet round-robin scheduler (for details see [3]).  A CBQ/WRR link is for class-based  queuing  with  a  weighted  round  robin
              scheduler.

       $$nnss mmuullttii--lliinnkk--ooff--iinntteerrffaacceess _n_o_d_e_-_l_i_s_t _b_w _d_e_l_a_y _t_y_p_e
              Connects the nodes specified in _n_o_d_e_-_l_i_s_t by a mesh of duplex links with interfaces (to simulate a broadcast LAN) with bandwidth _b_w in bits per second and link propagation delay _d_e_l_a_y in sec‐
              onds.  _n_o_d_e_-_l_i_s_t is a list of node object handles that have already been created with the _n_o_d_e method.  _b_w and _d_e_l_a_y default to 1.5 Mbits/sec and 100 ms respectively.   The  defaults  can  be
              changed  by  modifying  the  relevant  configuration parameters of the DelayLink Object (see DELAYLINK OBJECTS section).  The queuing discipline of the link is specified by _t_y_p_e_, which may be
              DDrrooppTTaaiill,, FFQQ SSFFQQ,, DDRRRR,, RREEDD,, CCBBQQ,, or CCBBQQ//WWRRRR..  A DropTail link is a simple FIFO queue which drops the last packet in the queue when the queue overflows.  A FQ link is  for  Fair  Queuing  (for
              details see [?]).  A SFQ link is for Stochastic Fair Queuing (for details see [?]).  A DRR link is for deficit round robin scheduling (for details see [9]).  A RED link is a random-early drop
              queue (for details see [2]).  A CBQ link is for class-based queuing using a packet-by-packet round-robin scheduler (for details see [3]).  A CBQ/WRR link is for  class-based  queuing  with  a
              weighted round robin scheduler.

       nneeww AAggeenntt//_t_y_p_e
              Create an Agent of type _t_y_p_e which may be:
                Null                  - Traffic Sink
                LossMonitor           - Traffic Sink that monitors loss parameters
                TCP                   - BSD Tahoe TCP
                TCP/FullTcp           - Full Reno TCP with two-way connections [11]
                TCP/Reno              - BSD Reno TCP
                TCP/Newreno           - a modified version of BSD Reno TCP
                TCP/Vegas             - Vegas TCP (from U. Arizonia via USC)
                TCP/Sack1             - BSD Reno TCP with selective ACKs
                TCP/Fack              - BSD Reno TCP with forward ACKs
                TCPSink               - standard TCP sink
                TCPSink/DelAck        - TCP sink that generates delayed ACKs
                TCPSink/Sack1         - TCP sink that generates selective ACKs
                TCPSink/Sack1/DelAck  - delayed-ack TCP sink with selective ACKs
                UDP                   - UDP Transport
                RTP                   - RTP agent
                Session/RTP           -
                RTCP                  - RTCP agent
                IVS/Source            -
                IVS/Receiver          -
                SRM                   -
              The  methods,  configuration parameters and the relevant state variables associated with these objects are discussed in detail in later sections.  Note that some agents e.g. TCP or SRM do not
              generate their own data.  Such agents need sources attached to them to generate data (see attach-source and attach-traffic methods in AGENT OBJECTS section).

       $$nnss aattttaacchh--aaggeenntt _n_o_d_e _a_g_e_n_t
              Attach the agent object _a_g_e_n_t to _n_o_d_e_.  The _a_g_e_n_t and _n_o_d_e objects should have already been created.

       $$nnss ddeettaacchh--aaggeenntt _n_o_d_e _a_g_e_n_t
              Detach the agent object _a_g_e_n_t from _n_o_d_e_.

       $$nnss ccoonnnneecctt _s_r_c _d_s_t
              Establish a two-way connection between the agent _s_r_c and the agent _d_s_t_.  Returns the handle to _s_r_c agent.  A helper method has been defined to facilitate creating and attaching  an  agent  to
              each of two nodes and establishing a two-way connection between them.  (see BUILTINS section).

       $$nnss uussee--sscchheedduulleerr _t_y_p_e
              Use  an  event scheduler of type _t_y_p_e in the simulations.  _t_y_p_e is one of List, Heap, Calendar, RealTime.  The List scheduler is the default.  A Heap scheduler uses a heap for event queueing.
              A Calendar scheduler uses a calendar queue to keep track of events.  RealTime scheduler is used in emulation mode when the simulator interacts with an external agent.

       $$nnss aatt _t_i_m_e _p_r_o_c_e_d_u_r_e
              Evaluate _p_r_o_c_e_d_u_r_e at simulation time _t_i_m_e_.  The procedure could be a globally accessible function (proc) or an object method (instproc).  This command can be used to start and stop  sources,
              dynamically reconfigure the simulator, dump statistics at specified intervals, etc.  Returns an event id.

       $$nnss ccaanncceell _e_i_d
              Remove the event specified by the event id _e_i_d from the event queue.

       $$nnss nnooww
              Return the current simulation time.

       $$nnss ggeenn--mmaapp
              Walks through the simulation topology and lists all the objects that have been created and the way they are hooked up to each other.  This is useful to debug simulation scripts.

       nnss--vveerrssiioonn
              Return a string identifying the version of ns currently running.  This method is executed in the global context by the interpreter.

       nnss--rraannddoomm _[ _s_e_e_d _]
              If  _s_e_e_d  is not present, return a pseudo-random integer between 0 and 2^31-1.  Otherwise, seed the pseudo-random number generator with _s_e_e_d and return the seed used.  If _s_e_e_d is 0, choose an
              initial seed heuristically (which varies on successive invocations).  This method is executed in the global context by the interpreter.

       Ns has other facilities for random number generation; please see documentation for details [13].


OOBBJJEECCTT HHIIEERRAARRCCHHYY
       A brief description of the object hierarchy in _n_s is presented in this section.  This description is not intended to be complete.  It has been provided to depict how the  methods  and  configuration
       parameters  associated  with  the various objects are inherited.  For more complete information see "ns notes & documentation" and the automatically generated class library information on the ns web
       page.

       Objects are associated with configuration parameters that can be dynamically set and queried, and state variables that can be queried (usually modified only when the state variables need to be reset
       for another simulation run).

       Configuration parameters represent simulation parameters that are usually fixed during the entire simulation (like a link bandwidth), but can be changed dynamically if desired.  State variables rep‐
       resent values that are specific to a given object and that object's implementation.

       The following diagram depicts a portion the object hierarchy:
           Simulator
                 MultiSim
           Node
           Link
                 SimpleLink
                      CBQLink
                 DummyLink
           DelayLink
           Queue
                 DropTail
                 FQ
                 SFQ
                 DRR
                 RED
                 CBQ
                 CBQ/WRR
           QueueMonitor
                 ED
                      Flowmon
                      Flow
           rtObject
           RouteLogic
           Agent
                 rtProto
                      Static
                      Session
                      DV
                      Direct
                 Null
                 LossMonitor
                 TCP
                      FullTcp
                      Reno
                      Newreno
                      Sack1
                      Fack
                 TCPSink
                      DelAck
                      Sack1
                          DelAck
                 UDP
                 RTP
                 RTCP
                 IVS
                      Source
                      Receiver
                 SRM
                 Session
                      RTP [how is this diff from Agent/CBR/RTP]
           Appplication
                 FTP
                 Telnet
                 Traffic
                      Expoo
                      Pareto
                      CBR
                      Trace
           Integrator
           Samples

       For a complete, automatically generated, object hierarchy, see the link "class hierarchy" (which points to http://www-sop.inria.fr/rodeo/personnel/Antoine.Clerget/ns/) on the ns web pages.   (Thanks
       to Antoine Clerget for maintaining this!)

       For  example,  any method that is supported by a _T_C_P agent is also supported by a _R_e_n_o or a _S_a_c_k_1 agent.  Default configuration parameters are also inherited.  For example, _$_t_c_p _s_e_t _w_i_n_d_o_w__ _2_0 where
       $tcp is a TCP agent defines the default TCP window size for both _T_C_P and _R_e_n_o objects.


OOBBJJEECCTT MMEETTHHOODDSS
       The following sections document the methods, configuration parameters and state variables associated with the various objects as well as those to enable Network dynamics, Unicast routing,  Multicast
       routing  and  Trace  and  Monitoring support.  The object class is specified implicitly by the object variable name in the description.  For example, $$ttccpp implies the tcp object class and all of its
       child classes.


NNOODDEE OOBBJJEECCTTSS
       [NOTE: This section has not been verified to be up-to-date with the release.]

       $$nnooddee iidd
              Returns the node id.

       $$nnooddee nneeiigghhbboorrss
              Returns a list of the neighbour node objects.

       $$nnooddee aattttaacchh _a_g_e_n_t
              Attach an agent of type _a_g_e_n_t to this node.

       $$nnooddee ddeettaacchh _a_g_e_n_t
              Detach an agent of type _a_g_e_n_t from this node.

       $$nnooddee aaggeenntt _p_o_r_t
              Return a handle to the agent attached to port _p_o_r_t on this node.  Returns an empty string if the port is not in use.

       $$nnooddee rreesseett
              Reset all agents attached to this node.  This would re-initialize the state variables associated with the various agents at this node.

       $$nnooddee rrttOObbjjeecctt??
              Returns a handle to rtObject if there exists an instance of the object at that node.  Only nodes that take part in a dynamic unicast routing protocol will have this object (see UNICAST  ROUT‐
              ING METHODS and RTOBJECT OBJECTS section).

       $$nnooddee jjooiinn--ggrroouupp _a_g_e_n_t _g_r_o_u_p
              Add  the agent specified by the object handle _a_g_e_n_t to the multicast host group identified by the address _g_r_o_u_p_.  This causes the group membership protocol to arrange for the appropriate mul‐
              ticast traffic to reach this agent.  Multicast group address should be in the range 0x8000 - 0xFFFF.

       $$nnooddee aallllooccaaddddrr
              Returns multicast group address in ascending order on each invocation starting from 0x8000 and ending at 0xFFFF.

       $$nnooddee sshhaappee _s_h_a_p_e
              Set the shape of the node to "_s_h_a_p_e". When called before the simulator starts to run, it changes the default shape of the node in the nam trace file. The default shape of a  node  is  """cir‐
              cle"""

       $$nnooddee ccoolloorr _c_o_l_o_r
              Set the color of the node to _c_o_l_o_r. It can be called anytime to change the current color of the node in nam trace file, if there is one.

       $$nnooddee ggeett--aattttrriibbuuttee _n_a_m_e
              Get the specified attribute _n_a_m_e of the node. Currently a Node object has two attributes: _C_O_L_O_R and _S_H_A_P_E. Note: these letters must be capital.

       $$nnooddee aadddd--mmaarrkk _n_a_m_e _c_o_l_o_r _s_h_a_p_e
              Add a mark (in nam trace file) with _c_o_l_o_r and _s_h_a_p_e around the node. The shape can be """circle""", """hexagon""" and """square""" (case sensitive). The added mark will be identified by _n_a_m_e.

       $$nnooddee ddeelleettee--mmaarrkk _n_a_m_e
              Delete the mark with _n_a_m_e in the given node.


       There are no state variables or configuration parameters specific to the node class.


LLIINNKK OOBBJJEECCTTSS
       [NOTE: This section has not been verified to be up-to-date with the release.]

       $$lliinnkk ttrraaccee--ddyynnaammiiccss _n_s _f_i_l_e_I_D
              Trace the dynamics of this link and write the output to _f_i_l_e_I_D filehandle.  _n_s is an instance of the Simulator or MultiSim object that was created to invoke the simulation (see TRACE AND MON‐
              ITORING METHODS section for the output trace format).

       $$lliinnkk ttrraaccee--ccaallllbbaacckk _n_s _c_m_d
              Trace all packets on the link with the callback _c_m_d.  Cmd is invoked for each trace event (enqueue, dequeue, drop) with the text that would be logged as parameters.  (See the  description  of
              the log file for this information.)  A demo of trace callbacks is in the program tcl/ex/callback_demo.tcl in the distribution.

       $$lliinnkk ccoolloorr _c_o_l_o_r
              Set the color of the Link object. It can be called anytime to change the current color of the link in nam trace file, if there is one.

       $$lliinnkk ggeett--aattttrriibbuuttee _n_a_m_e
              Get the specified attribute _n_a_m_e of the Link. Currently a Link object has three attributes: _C_O_L_O_R, _O_R_I_E_N_T_A_T_I_O_N, and _Q_U_E_U_E___P_O_S.

       Currently the following two functions should not be directly called. Use $$nnss dduupplleexx--lliinnkk--oopp instead. Refer to the corresponding section in this man page.

       $$lliinnkk oorriieenntt _o_r_i
              Set  the  orientation  of the link to _o_r_i. When called before the simulator starts to run, it changes the default orientation of the link in nam trace file, if there is one. If orientation is
              unspecified for any link(s), nam will use automatic layout. The default orientation of a Link object is unspecified.

       $$lliinnkk qquueeuueePPooss _p_o_s
              Set the queue position of the link to _p_o_s. When called before the simulator starts to run, it changes the default queue placement of the simplex link in nam trace file, if there is  one.  _p_o_s
              specifies the angle between the horizontal line and the line along which queued packets will be displayed.


SSIIMMPPLLEELLIINNKK OOBBJJEECCTTSS
       [NOTE: This section has not been verified to be up-to-date with the release.]

       $$lliinnkk ccoosstt _c_o_s_t_-_v_a_l
              Make _c_o_s_t_-_v_a_l the cost of this link.

       $$lliinnkk ccoosstt??
              Return the cost of this link.

       Any configuration parameters or state variables?


DDEELLAAYYLLIINNKK OOBBJJEECCTTSS
       [NOTE:  This  section  has  not been verified to be up-to-date with the release.]  The DelayLink Objects determine the amount of time required for a packet to traverse a link.  This is defined to be
       size/bw + delay where size is the packet size, bw is the link bandwidth and delay is the link propagation delay.  There are no methods or state variables associated with this object.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _b_a_n_d_w_i_d_t_h__
                     Link bandwidth in bits per second.

              _d_e_l_a_y__ Link propagation delay in seconds.

              There are no state variables associated with this object.


NNEETTWWOORRKK DDYYNNAAMMIICCSS MMEETTHHOODDSS
       This section describes methods to make the links and nodes in the topology go up and down according to various distributions.  A dynamic routing protocol should generally be used whenever a  simula‐
       tion is to be done with network dynamics.  Note that a static topology model is the default in ns.

       $$nnss rrttmmooddeell _m_o_d_e_l _m_o_d_e_l_-_p_a_r_a_m_s _n_o_d_e_1 _[_n_o_d_e_2_]
              Make  the  link between _n_o_d_e_1 and _n_o_d_e_2 change between up and down states according to the model _m_o_d_e_l_.  In case only _n_o_d_e_1 is specified all the links incident on the node would be brought up
              and down according to the specified _m_o_d_e_l_.  _m_o_d_e_l_-_p_a_r_a_m_s contains the parameters required for the relevant model and is to be specified as a list i.e. the parameters are  to  be  enclosed  in
              curly brackets.  _m_o_d_e_l can be one of _D_e_t_e_r_m_i_n_i_s_t_i_c_, _E_x_p_o_n_e_n_t_i_a_l_, _M_a_n_u_a_l_, _T_r_a_c_e_.  Returns a handle to a model object corresponding to the specified _m_o_d_e_l_.

              In  the Deterministic model _m_o_d_e_l_-_p_a_r_a_m_s is _[_s_t_a_r_t_-_t_i_m_e_] _u_p_-_i_n_t_e_r_v_a_l _d_o_w_n_-_i_n_t_e_r_v_a_l _[_f_i_n_i_s_h_-_t_i_m_e_]_.  Starting from _s_t_a_r_t_-_t_i_m_e the link is made up for _u_p_-_i_n_t_e_r_v_a_l and down for _d_o_w_n_-_i_n_t_e_r_v_a_l till
              _f_i_n_i_s_h_-_t_i_m_e is reached.  The default values for start-time, up-interval, down-interval are 0.5s, 2.0s, 1.0s respectively.  finish-time defaults to the end of the simulation.   The  start-time
              defaults to 0.5s in order to let the routing protocol computation quiesce.

              If the Exponential model is used _m_o_d_e_l_-_p_a_r_a_m_s is of the form _u_p_-_i_n_t_e_r_v_a_l _d_o_w_n_-_i_n_t_e_r_v_a_l where the link up-time is an exponential distribution around the mean _u_p_-_i_n_t_e_r_v_a_l and the link down-time
              is an exponential distribution around the mean _d_o_w_n_-_i_n_t_e_r_v_a_l_.  Default values for _u_p_-_i_n_t_e_r_v_a_l and _d_o_w_n_-_i_n_t_e_r_v_a_l are 10s and 1s respectively.

              If the Manual distribution is used _m_o_d_e_l_-_p_a_r_a_m_s is _a_t _o_p where _a_t specifies the time at which the operation _o_p should occur.  _o_p is one of _u_p_, _d_o_w_n_.  The Manual distribution could  be  speci‐
              fied alternately using the _r_t_m_o_d_e_l_-_a_t method described later in the section.

              If  Trace  is  specified  as the _m_o_d_e_l the link/node dynamics is read from a Tracefile.  The _m_o_d_e_l_-_p_a_r_a_m_s argument would in this case be the file-handle of the Tracefile that has the dynamics
              information.  The tracefile format is identical to the trace output generated by the trace-dynamics link method (see TRACE AND MONITORING METHODS SECTION).


       $$nnss rrttmmooddeell--ddeelleettee _m_o_d_e_l_-_h_a_n_d_l_e
              Delete the instance of the route model specified by _m_o_d_e_l_-_h_a_n_d_l_e_.


       $$nnss rrttmmooddeell--aatt _a_t _o_p _n_o_d_e_1 _[_n_o_d_e_2_]
              Used to specify the up and down times of the link between nodes _n_o_d_e_1 and _n_o_d_e_2_.  If only _n_o_d_e_1 is given all the links incident on _n_o_d_e_1 will be brought up and down.  _a_t is the time at  which
              the operation _o_p that can be either _u_p or _d_o_w_n is to be performed on the specified link(s).


QQUUEEUUEE OOBBJJEECCTTSS
       A queue object is a general class of object capable of holding and possibly marking or discarding packets as they travel through the simulated topology.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _l_i_m_i_t__ The queue size in packets.

              _b_l_o_c_k_e_d__
                     Set to false by default, this is true if the queue is blocked (unable to send a packet to its downstream neighbor).

              _u_n_b_l_o_c_k___o_n___r_e_s_u_m_e__
                     Set to true by default, indicates a queue should unblock itself at the time the last packet packet sent has been transmitted (but not necessarily received).


DDRROOPP--TTAAIILL OOBBJJEECCTTSS
       Drop-tail  objects  are  a subclass of Queue objects that implement simple FIFO queue.  There are no methods that are specific to drop-tail objects.  The only configuration parameter is _d_r_o_p_-_f_r_o_n_t__,
       which when set to true causes the queue to behave as a drop-from-front queueing discipline.  This variable is set to false by default.


FFQQ OOBBJJEECCTTSS
       FQ objects are a subclass of Queue objects that implement Fair queuing.  There are no methods that are specific to FQ objects.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _s_e_c_s_P_e_r_B_y_t_e__

              There are no state variables associated with this object.


SSFFQQ OOBBJJEECCTTSS
       SFQ objects are a subclass of Queue objects that implement Stochastic Fair queuing.  There are no methods that are specific to SFQ objects.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _m_a_x_q_u_e_u_e__

              _b_u_c_k_e_t_s__

              There are no state variables associated with this object.


DDRRRR OOBBJJEECCTTSS
       DRR objects are a subclass of Queue objects that implement deficit round robin scheduling. These objects implement deficit round robin scheduling amongst different flows ( A particular flow  is  one
       which  has  packets with the same node and port id OR packets which have the same node id alone). Also unlike other multi-queue objects, this queue object implements a single shared buffer space for
       its different flows.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _b_u_c_k_e_t_s__
                     Indicates the total number of buckets to be used for hashing each of the flows.

              _b_l_i_m_i_t__
                     Indicates the shared buffer size in bytes.

              _q_u_a_n_t_u_m__
                     Indicates (in bytes) how much each flow can send during its turn.

              _m_a_s_k__  mask_, when set to 1, means that a particular flow consists of packets having the same node id (and possibly different port ids), otherwise a flow consists of packets having  the  same
                     node and port ids.



RREEDD OOBBJJEECCTTSS
       RED  objects are a subclass of Queue objects that implement random early-detection gateways.  The object can be configured to either drop or ``mark'' packets.  There are no methods that are specific
       to RED objects.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _b_y_t_e_s__ Set to "true" to enable ``byte-mode'' RED, where the size of arriving packets affect the likelihood of marking (dropping) packets.

              _q_u_e_u_e_-_i_n_-_b_y_t_e_s__
                     Set to "true" to measure the average queue size in bytes rather than packets.  Enabling this option also causes _t_h_r_e_s_h__ and _m_a_x_t_h_r_e_s_h__ to be automatically scaled by _m_e_a_n___p_k_t_s_i_z_e__  (see
                     below).

              _t_h_r_e_s_h__
                     The minimum threshold for the average queue size in packets.

              _m_a_x_t_h_r_e_s_h__
                     The maximum threshold for the average queue size in packets.

              _m_e_a_n___p_k_t_s_i_z_e__
                     A rough estimate of the average packet size in bytes.  Used in updating the calculated average queue size after an idle period.

              _q___w_e_i_g_h_t__
                     The queue weight, used in the exponential-weighted moving average for calculating the average queue size.

              _w_a_i_t__  Set to true to maintain an interval between dropped packets.

              _l_i_n_t_e_r_m__
                     As the average queue size varies between "thresh_" and "maxthresh_", the packet dropping probability varies between 0 and "1/linterm".

              _s_e_t_b_i_t__
                     Set to "true" to mark packets by setting the congestion indication bit in packet headers rather than drop packets.

              _d_r_o_p_-_t_a_i_l__
                     Set  to  true to use drop-tail rather than random-drop or drop-from-front when the queue overflows or the average queue size exceeds "maxthresh_".  This is the default behavior.  For a
                     further explanation of these variables, see [2].

              _d_r_o_p_-_r_a_n_d__
                     Set to true to use random-drop rather than drop-tail or drop-from-front when the queue overflows or the average queue size exceeds "maxthresh_".

              _d_r_o_p_-_f_r_o_n_t__
                     Set to true to use drop-from-front rather than drop-tail or random drop when the queue overflows or the average queue size exceeds "maxthresh_".

              _n_s_1_-_c_o_m_p_a_t__
                     Set to true to avoid resetting the count since the last packet drop, after a forced packet is dropped.  This gives compatibility with previous behavior of RED.  The default is  set  to
                     false.

              entle_ Set  to  true  to  increase  the  packet  drop  rate  slowly from max_p to 1 as the average queue size ranges from maxthresh to twice maxthresh.  The default is set to false, and max_p
                     increases abruptly from max_p to 1 when the average queue size exceeds maxthresh.

              SSttaattee VVaarriiaabblleess
                     None of the state variables of the RED implementation are accessible.


CCBBQQ OOBBJJEECCTTSS
       CBQ objects are a subclass of Queue objects that implement class-based queueing.

       $$ccbbqq iinnsseerrtt $$ccllaassss
              Insert traffic class _c_l_a_s_s into the link-sharing structure associated with link object _c_b_q_.

       $$ccbbqq bbiinndd $$ccbbqqccllaassss $$iidd11 [[$$iidd22]]
              Cause packets containing flow id _$_i_d_1 (or those in the range _$_i_d_1 to _$_i_d_2 inclusive) to be associated with the traffic class _$_c_b_q_c_l_a_s_s_.

       $$ccbbqq aallggoorriitthhmm $$aallgg
              Select the CBQ internal algorithm.  _$_a_l_g may be set to one of: "ancestor-only", "top-level", or "formal".

CCBBQQ//WWRRRR OOBBJJEECCTTSS
       CBQ/WRR objects are a subclass of CBQ objects that implement weighted round-robin scheduling among classes of the same priority level.  In contrast, CBQ  objects  implement  packet-by-packet  round-
       robin scheduling among classes of the same priority level.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _m_a_x_p_k_t__
                     The maximum size of a packet in bytes.  This is used only by CBQ/WRR objects in computing maximum bandwidth allocations for the weighted round-robin scheduler.


CCBBQQCCLLAASSSS OOBBJJEECCTTSS
       CBQClass objects implement the traffic classes associated with CBQ objects.

       $$ccbbqqccllaassss sseettppaarraammss _p_a_r_e_n_t _o_k_b_o_r_r_o_w _a_l_l_o_t _m_a_x_i_d_l_e _p_r_i_o _l_e_v_e_l _e_x_t_r_a_d_e_l_a_y
              Sets several of the configuration parameters for the CBQ traffic class (see below).

       $$ccbbqqccllaassss ppaarreenntt [[$$ccbbqqccll||nnoonnee]]
              specify the parent of this class in the link-sharing tree.  The parent may be specified as ``none'' to indicate this class is a root.

       $$ccbbqqccllaassss nneewwaalllloott $$aa
              Change the link allocation of this class to the specified amount (in range 0.0 to 1.0).  Note that only the specified class is affected.

       $$ccbbqqccllaassss iinnssttaallll--qquueeuuee $$qq
              Install a Queue object into the compound CBQ or CBQ/WRR link structure.  When a CBQ object is initially created, it includes no internal queue (only a packet classifier and scheduler).

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              ookkbboorrrrooww__
                     is a boolean indicating the class is permitted to borrow bandwidth from its parent.

              aalllloott__ is the maximum fraction of link bandwidth allocated to the class expressed as a real number between 0.0 and 1.0.

              mmaaxxiiddllee__
                     is the maximum amount of time a class may be required to have its packets queued before they are permitted to be forwarded

              pprriioorriittyy__
                     is  the class' priority level with respect to other classes.  This value may range from 0 to 10, and more than one class may exist at the same priority.  Priority 0 is the highest pri‐
                     ority.

              lleevveell__ is the level of this class in the link-sharing tree.  Leaf nodes in the tree are considered to be at level 1; their parents are at level 2, etc.

              eexxttrraaddeellaayy__
                     increase the delay experienced by a delayed class by the specified number of seconds.


QQUUEEUUEEMMOONNIITTOORR OObbjjeeccttss
       QueueMonitor Objects are used to monitor a set of packet and byte arrival, departure and drop counters.  It also includes support for aggregate statistics such as  average  queue  size,  etc.   [see
       TRACE AND MONITORING METHODS].

       $$qquueeuueemmoonniittoorr rreesseett
              reset all the cumulative counters described below (arrivals, departures, and drops) to zero.  Also, reset the integrators and delay sampler, if defined.

       $$qquueeuueemmoonniittoorr sseett--ddeellaayy--ssaammpplleess _d_e_l_a_y_S_a_m_p__
              Set up the Samples object _d_e_l_a_y_S_a_m_p__ to record statistics about queue delays.  _d_e_l_a_y_S_a_m_p__ is a handle to a Samples object i.e the Samples object should have already been created.

       $$qquueeuueemmoonniittoorr ggeett--bbyytteess--iinntteeggrraattoorr
              Returns an Integrator object that can be used to find the integral of the queue size in bytes.  (see Integrator Objects section).

       $$qquueeuueemmoonniittoorr ggeett--ppkkttss--iinntteeggrraattoorr
              Returns an Integrator object that can be used to find the integral of the queue size in packets.  (see Integrator Objects section).

       $$qquueeuueemmoonniittoorr ggeett--ddeellaayy--ssaammpplleess
              Returns a Samples object _d_e_l_a_y_S_a_m_p__ to record statistics about queue delays (see Samples Objects section).

       There are no configuration parameters specific to this object.

       SSttaattee VVaarriiaabblleess

              _s_i_z_e__  Instantaneous queue size in bytes.

              _p_k_t_s__  Instantaneous queue size in packets.

              _p_a_r_r_i_v_a_l_s__
                     Running total of packets that have arrived.

              _b_a_r_r_i_v_a_l_s__
                     Running total of bytes contained in packets that have arrived.

              _p_d_e_p_a_r_t_u_r_e_s__
                     Running total of packets that have departed (not dropped).

              _b_d_e_p_a_r_t_u_r_e_s__
                     Running total of bytes contained in packets that have departed (not dropped).

              _p_d_r_o_p_s__
                     Total number of packets dropped.

              _b_d_r_o_p_s__
                     Total number of bytes dropped.

              _b_y_t_e_s_I_n_t__
                     Integrator object that computes the integral of the queue size in bytes.  The _s_u_m__ variable of this object has the running sum (integral) of the queue size in bytes.

              _p_k_t_s_I_n_t__
                     Integrator object that computes the integral of the queue size in packets.  The _s_u_m__ variable of this object has the running sum (integral) of the queue size in packets.


QQUUEEUUEEMMOONNIITTOORR//EEDD OObbjjeeccttss
       This  derived  object  is capable of differentiating regular packet drops from _e_a_r_l_y drops.  Some queues distinguish regular drops (e.g. drops due to buffer exhaustion) from other drops (e.g. random
       drops in RED queues).  Under some circumstances, it is useful to distinguish these two types of drops.

       SSttaattee VVaarriiaabblleess

              _e_p_d_r_o_p_s__
                     The number of packets that have been dropped ``early''.

              _e_b_d_r_o_p_s__
                     The number of bytes comprising packets that have been dropped ``early''

       NNoottee:: because this class is a subclass of QueueMonitor, objects of this type also have fields such as pdrops_ and bdrops_.  These fields describe the _t_o_t_a_l  number  of  dropped  packets  and  bytes,
       including both early and non-early drops.


QQUUEEUUEEMMOONNIITTOORR//EEDD//FFLLOOWWMMOONN OObbjjeeccttss
       These objects may be used in the place of a conventional QueueMonitor object when wishing to collect per-flow counts and statistics in addition to the aggregate counts and statistics provided by the
       basic QueueMonitor.

       $$ffmmoonn ccllaassssiiffiieerr [[$$ccll]]
              insert (read) the specified classifier into (from) the flow monitor object.  This is used to map incoming packets to which flows they are associated with.

       $$ffmmoonn dduummpp
              Dump the current per-flow counters and statistics to the I/O channel specified in a previous attach operation.

       $$ffmmoonn fflloowwss
              Return a character string containing the names of all flow objects known by this flow monitor.  Each of these objects are of type QueueMonitor/ED/Flow.

       $$ffmmoonn aattttaacchh $$cchhaann
              Attach a tcl I/O channel to the flow monitor.  Flow statistics are written to the channel when the dump operation is executed.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              eennaabbllee__iinn__
                     Set to true by default, indicates that per-flow arrival state should be kept by the flow monitor.  If set to false, only the aggregate arrival information is kept.

              eennaabbllee__oouutt__
                     Set to true by default, indicates that per-flow departure state should be kept by the flow monitor.  If set to false, only the aggregate departure information is kept.

              eennaabbllee__ddrroopp__
                     Set to true by default, indicates that per-flow drop state should be kept by the flow monitor.  If set to false, only the aggregate drop information is kept.

              eennaabbllee__eeddrroopp__
                     Set to true by default, indicates that per-flow early drop state should be kept by the flow monitor.  If set to false, only the aggregate early drop information is kept.


QQUUEEUUEEMMOONNIITTOORR//EEDD//FFLLOOWW OObbjjeeccttss
       These objects contain per-flow counts and statistics managed by a QUEUEMONITOR/ED/FLOWMON object.  They are generally created in an OTcl callback procedure when a flow monitor is given a  packet  it
       cannot map on to a known flow.  Note that the flow monitor's classifier is responsible for mapping packets to flows in some arbitrary way.  Thus, depending on the type of classifier used, not all of
       the state variables may be relevant (e.g. one may classify packets based only on flow id, in which case the source and destination addresses may not be significant).

       SSttaattee VVaarriiaabblleess

              ssrrcc__   The source address of packets belonging to this flow.

              ddsstt__   The destination address of packets belonging to this flow.

              fflloowwiidd__
                     The flow id of packets belonging to this flow.


UUNNIICCAASSTT RROOUUTTIINNGG MMEETTHHOODDSS
       A dynamic unicast routing protocol can be specified to run on a subset of nodes in the topology.  Note that a dynamic routing protocol should be generally used whenever a  simulation  is  done  with
       network dynamics.

       $$nnss rrttpprroottoo _p_r_o_t_o _n_o_d_e_-_l_i_s_t
              Specifies  the  dynamic unicast routing protocol _p_r_o_t_o to be run on the nodes specified by _n_o_d_e_-_l_i_s_t_.  Currently _p_r_o_t_o can be one of Static, Session, DV.  Static routing is the default.  Ses‐
              sion implies that the unicast routes over the entire topology are instantaneously recomputed whenever a link goes up or down.  DV implies that a simple distance vector routing protocol is  to
              be simulated.  _n_o_d_e_-_l_i_s_t defaults to all the nodes in the topology.

       $$nnss ccoommppuuttee--rroouutteess
              Compute  routes  between all the nodes in the topology.  This can be used if static routing is done and the routes have to be recomputed as the state of a link has changed.  Note that Session
              routing (see _r_t_p_r_o_t_o method above) will recompute routes automatically whenever the state of any link in the topology changes.

       $$nnss ggeett--rroouutteellooggiicc
              Returns an handle to a RouteLogic object that has methods for route table lookup etc.


RROOUUTTEELLOOGGIICC OOBBJJEECCTTSS
       $$rroouutteellooggiicc llooookkuupp _s_r_c_i_d _d_e_s_t_i_d
              Returns the id of the node that is the next hop from the node with id _s_r_c_i_d to the node with id _d_e_s_t_i_d_.

       $$rroouutteellooggiicc dduummpp _n_o_d_e_i_d
              Dump the routing tables of all nodes whose id is less than _n_o_d_e_i_d_.  Node ids are typically assigned to nodes in ascending fashion starting from 0 by their order of creation.


RRTTOOBBJJEECCTT OOBBJJEECCTTSS
       Every node that takes part in a dynamic unicast routing protocol will have an instance of rtObject (see NODE OBJECTS section for the method to get an handle to this object  at  a  particular  node).
       Note that nodes will not have an instance of this object if Session routing is done as a detailed routing protocol is not being simulated in this case.

       $$rrttoobbjjeecctt dduummpp--rroouutteess _f_i_l_e_I_D
              Dump the routing table to the output channel specified by _f_i_l_e_I_D_.  _f_i_l_e_I_D must be a file handle returned by the Tcl _o_p_e_n command and it must have been opened for writing.

       $$rrttoobbjjeecctt rrttPPrroottoo?? _p_r_o_t_o
              Returns a handle to the routing protocol agent specified by _p_r_o_t_o if it exists at that node.  Returns an empty string otherwise.

       $$rrttoobbjjeecctt nneexxttHHoopp?? _d_e_s_t_I_D
              Returns the id of the node that is the next hop to the destination specified by the node id, _d_e_s_t_I_D_.

       $$rrttoobbjjeecctt rrttpprreeff?? _d_e_s_t_I_D

       $$rrttoobbjjeecctt mmeettrriicc?? _d_e_s_t_I_D


MMUULLTTIICCAASSTT RROOUUTTIINNGG MMEETTHHOODDSS
       Multicast  routing is enabled by setting Simulator EnableMcast_ variable to 1 at the beginning of the simulation.  Note that this variable must be set before any node, link or agent objects are cre‐
       ated in the simulation.  Also links must have been created with interface labels (see simplex-link and duplex-link methods in NS COMMANDS section).

       $$nnss mmrrttpprroottoo _p_r_o_t_o _n_o_d_e_-_l_i_s_t
              Specifies the multicast routing protocol _p_r_o_t_o to be run on the nodes specified by _n_o_d_e_-_l_i_s_t_.  Currently _p_r_o_t_o can be one of CtrMcast, DM, detailedDM, dynamicDM, pimDM.  _n_o_d_e_-_l_i_s_t defaults to
              all  the nodes in the topology.  Returns an handle to a protocol-specific object that has methods, configuration parameters specific to that protocol.  Note that currently CtrMcastComp object
              is returned if CtrMcast is used but a null string is returned if DM, detailedDM, dynamicDM or pimDM are used.

              If proto is 'CtrMcast' a Rendezvous Point (RP) rooted shared tree is built for a multicast group.  The actual sending of prune, join messages etc.  to set up state at the nodes is  not  simu‐
              lated.   A centralized computation agent is used to compute the fowarding trees and set up multicast forwarding state, (*,G) at the relevant nodes as new receivers join a group.  Data packets
              from the senders to a group are unicast to the RP.  Methods are provided in the CtrMcastComp object (see CTRMCASTCOMP OBJECTS section) that is returned by mrtproto to  switch  to  source-spe‐
              cific trees, choose some nodes as candidate RPs etc.  When a node/link on a multicast distribution tree goes down, the tree is instanteously recomputed.

              If proto is 'DM' DVMRP-like dense mode is simulated.  Parent-child lists are used to reduce the number of links over which the data packets are broadcast.  Prune messages are sent by nodes to
              remove branches from the multicast forwarding tree that do not lead to any group members.  The prune timeout value is 0.5s by default (see DM OBJECTS section to  change  the  default).   This
              does not adapt to network changes.  There is also currently no support for proper functioning in topologies with LANs.

              If  proto is 'detailedDM' a dense mode protocol based on Protocol Independent Multicast - Dense Mode (PIM-DM) is simulated.  This is currently the most complete version of the dense mode pro‐
              tocol in the simulator and is recommended for use over the other dense mode protocols.  It adapts to network dynamics and functions correctly in topologies with LANs (where LANs  are  created
              using the multi-link-of-interfaces method - see NS COMMANDS).  In case there are multiple potential forwarders for a LAN, the node with the highest id is chosen as the forwarder (this is done
              through the Assert mechanism).  The default values for the prune timeout, interface deletion timeout (used for LANs) and graft retransmission timeout are 0.5s, 0.1s  and  0.05s  respectively.
              (see Prune/Iface/Timer, Deletion/Iface/Timer and GraftRtx/Timer objects respectively to change the default values and for more information about the timers).

              If  proto  is  'dynamicDM'  DVMRP-like dense mode protocol that adapts to network changes is simulated.  'Poison-reverse' information (i.e. the information that a particular neighbouring node
              uses this node to reach a particular network) is read from the routing tables of neighbouring nodes in order to adapt to network dynamics (DVMRP runs its own  unicast  routing  protocol  that
              exchanges  this  information).   The current implementation does not support proper functioning in topologies with LANs.  The prune timeout value is 0.5s by default (see DM OBJECTS section to
              change the default).

              If proto is 'pimDM' Protocol Independent Multicast - Dense mode is simulated.  In this case the data packets are broadcast over all the outgoing links except the incoming  link.   Prune  mes‐
              sages  are sent by nodes to remove the branches of the multicast forwarding tree that do not lead to any group members.  The current implementation does not adapt to network dynamics and does
              not support proper functioning in topologies with LANs.  The prune timeout value is 0.5s by default (see DM OBJECTS section to change the default).


CCTTRRMMCCAASSTTCCOOMMPP OOBBJJEECCTTSS
       A handle to the CtrMcastComp object is returned when the protocol is specified as 'CtrMcast' in mrtproto.

       $$ccttrrmmccaassttccoommpp sswwiittcchh--ttrreeeettyyppee _g_r_o_u_p_-_a_d_d_r
              Switch from the Rendezvous Point rooted shared tree to source-specific trees for the group specified by _g_r_o_u_p_-_a_d_d_r_.  Note that this method cannot be used to switch from source-specific  trees
              back to a shared tree for a multicast group.

       $$ccttrrmmccaassttccoommpp sseett__cc__rrpp _n_o_d_e_-_l_i_s_t
              Make  all  the nodes specified in _n_o_d_e_-_l_i_s_t as candidate RPs and change the state of all the other nodes to not be candidate RPs.  Note that all nodes are candidate RPs by default.  Currently
              the node with the highest node id serves as the RP for all multicast groups.  This method should be invoked before any source starts sending packets to the group or  any  receiver  joins  the
              group.

       $$ccttrrmmccaassttccoommpp ggeett__rrpp _n_o_d_e _g_r_o_u_p
              Returns  the RP for the group as seen by the node _n_o_d_e for the multicast group with address _g_r_o_u_p_-_a_d_d_r_.  Note that different nodes may see different RPs for the group if the network is parti‐
              tioned as the nodes might be in different partitions.


DDMM OOBBJJEECCTTSS
       DM Objects implement DVMRP style densemode multicast where parent-child lists are used to reduce the number of links over which initial data packets are broadcast.  There are  no  methods  or  state
       variables specific to this object.

       CCoonnffiigguurraattiioonn ppaarraammeetteerrss

              _P_r_u_n_e_T_i_m_e_o_u_t

              Timeout value for the prune state at nodes.


PPRRUUNNEE//IIFFAACCEE//TTIIMMEERR OOBBJJEECCTTSS
       The Prune/Iface/Timer objects are used to implement the prune timer for detailedDM.  There are no methods or state variables specific to this object.

       CCoonnffiigguurraattiioonn ppaarraammeetteerrss

              _t_i_m_e_o_u_t

              Timeout value for the prune state at nodes.


DDEELLEETTIIOONN//IIFFAACCEE//TTIIMMEERR OOBBJJEECCTTSS
       The  Deletion/Iface/Timer  objects  are  used to implement the interface deletion timer that are required for correct functioning at nodes that are part of LANs.  If a node has a LAN as its incoming
       interface for packets from a certain source and it does not have any downstream members it sends out a prune message onto the LAN.  Any node that has the LAN as its incoming interface for  the  same
       source  and  has  downstream  members on hearing the prune message sent on the LAN.  will send a join message onto the LAN.  When the node that is acting as the forwarder for the LAN hears the prune
       message from the LAN, it does not immediately prune off the LAN as its outgoing interface.  Instead it starts an interface deletion timer for the outgoing interface.  The forwarder will  remove  the
       LAN as its outgoing interface only if it does not receive any join messages from the LAN before its deletion timer expires.  There are no methods or state variables specific to this object.

       CCoonnffiigguurraattiioonn ppaarraammeetteerrss

              _t_i_m_e_o_u_t

              Timeout value for the interface deletion timer.


GGRRAAFFTTRRTTXX//TTIIMMEERR OOBBJJEECCTTSS
       The GraftRtx/Timer objects are used to implement the graft retransmission timer at nodes.  This is to ensure the reliability of grafts sent upstream by a node.

       CCoonnffiigguurraattiioonn ppaarraammeetteerrss

              _t_i_m_e_o_u_t

              Timeout value for the graft retransmission timer.


AAGGEENNTT OOBBJJEECCTTSS
       [NOTE: This section has not been verified to be up-to-date with the release.]

       $$aaggeenntt ppoorrtt
              Return the transport-level port of the agent.  Ports are used to identify agents within a node.

       $$aaggeenntt ddsstt--aaddddrr
              Return the address of the destination node this agent is connected to.

       $$aaggeenntt ddsstt--ppoorrtt
              Return the port at the destination node that this agent is connected to.

       $$aaggeenntt aattttaacchh--ssoouurrccee _t_y_p_e
              Install  a  data source of type _t_y_p_e in this agent.  _t_y_p_e is one of FTP or bursty[???].  See the corresponding object methods for information on configuration parameters.  Returns a handle to
              the source object.

       $$aaggeenntt aattttaacchh--ttrraaffffiicc _t_r_a_f_f_i_c_-_o_b_j_e_c_t
              Attach _t_r_a_f_f_i_c_-_o_b_j_e_c_t to this agent _t_r_a_f_f_i_c_-_o_b_j_e_c_t is an instance of Traffic/Expoo, Traffic/Pareto or Traffic/Trace.  Traffic/Expoo generates traffic based on an Exponential On/Off  distribu‐
              tion.  Traffic/Pareto generates traffic based on a Pareto On/Off distribution.  Traffic/Trace generates traffic from a trace file.  The relevant configuration parameters for each of the above
              objects can be found in the TRAFFIC METHODS section.

       $$aaggeenntt ccoonnnneecctt _a_d_d_r _p_o_r_t
              Connect this agent to the agent identified by the address _a_d_d_r and port _p_o_r_t_.  This causes packets transmitted from this agent to contain the address and port indicated, so that such  packets
              are  routed  to  the intended agent.  The two agents must be compatible (e.g., a tcp-source/tcp-sink pair as opposed a cbr/tcp-sink pair).  Otherwise, the results of the simulation are unpre‐
              dictable.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _d_s_t__   Address of destination that the agent is connected to. Currently 32 bits with the higher 24 bits the destination node ID and the lower 8 bits being the port number.

              There are no state variables specific to the generic agent class.


NNUULLLL OOBBJJEECCTTSS
       [NOTE: This section has not been verified to be up-to-date with the release.]  Null objects are a subclass of agent objects that implement a traffic sink.  They inherit  all  of  the  generic  agent
       object functionality.  There are no methods, configuration parameters or state variables specific to this object.


LLOOSSSSMMOONNIITTOORR OOBBJJEECCTTSS
       [NOTE:  This section has not been verified to be up-to-date with the release.]  LossMonitor objects are a subclass of agent objects that implement a traffic sink which also maintains some statistics
       about the received data e.g., number of bytes received, number of packets lost etc.  They inherit all of the generic agent object functionality.

       $$lloossssmmoonniittoorr cclleeaarr
              Resets the expected sequence number to -1.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              There are no configuration parameters specific to this object.

       SSttaattee VVaarriiaabblleess

              _n_l_o_s_t__ Number of packets lost.

              _n_p_k_t_s__ Number of packets received.

              _b_y_t_e_s__ Number of bytes received.

              _l_a_s_t_P_k_t_T_i_m_e__
                     Time at which the last packet was received.

              _e_x_p_e_c_t_e_d__
                     The expected sequence number of the next packet.


TTCCPP OOBBJJEECCTTSS
       TCP objects are a subclass of agent objects that implement the BSD Tahoe TCP transport protocol as described in [7].  They inherit all of the generic agent functionality.

       To trace TCP parameters, mark each parameter with ``$tcp trace window_'' and then send the output to a trace file with ``$tcp attach [open trace.tr w]''.

       Tcp segments can be sent with the advance and advanaceby commands.  When all data is sent, the done method will be invoked (which can be overridden in OTcl).

       $$ttccpp aaddvvaannccee nn
              Send up to the nth packets.

       $$ttccpp aaddvvaanncceebbyy nn
              Send n more packets.

       $$ttccpp ddoonnee
              Functional called when all packets (specified by advance/advanceby/maxpkts_) have been sent.  Can be overriden on a per-object basis.

              CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _w_i_n_d_o_w__
                     The upper bound on the advertised window for the TCP connection (in packets).

              _m_a_x_c_w_n_d__
                     The upper bound on the congestion window for the TCP connection.  Set to zero to ignore.  (This is the default.)  Measured in packets.

              _w_i_n_d_o_w_I_n_i_t__
                     The initial size of the congestion window on slow-start.  (in packets).

              _w_n_d___i_n_i_t___o_p_t_i_o_n__
                     The algorithm used for determining the initial size of the congestion window.  Set to 1 for a static algorithm using the value in _w_i_n_d_o_w_I_n_i_t__.  Set to 2 for a dynamic algorithm using a
                     function of _p_a_c_k_e_t_S_i_z_e__.

              _s_y_n__   Set to true to model the initial SYN/ACK exchange in one-way TCP.  Set to false as default.

              _d_e_l_a_y___g_r_o_w_t_h__
                     Set to true to delay the initial congestion window until after one packet has been sent and acked.  Set to false as default.

              _w_i_n_d_o_w_O_p_t_i_o_n__
                     The algorithm to use for managing the congestion window in linear phase.  The standard algorithm is 1 (the default).  Other experimental algorithms are documented in the source code.

              _w_i_n_d_o_w_T_h_r_e_s_h__
                     Gain constant to exponential averaging filter used to compute _a_w_n_d (see below).  For investigations of different window-increase algorithms.

              _o_v_e_r_h_e_a_d__
                     The  range  (in seconds) of a uniform random variable used to delay each output packet.  The idea is to insert random delays at the source in order to avoid phase effects, when desired
                     [4].  This has only been implemented for the Tahoe ("tcp") version of tcp, not for tcp-reno.  This is not intended to be a realistic model of CPU processing overhead.

              _e_c_n__   Set to true to use explicit congestion notification in addition to packet drops to signal congestion.  This allows a Fast Retransmit after a quench() due to an ECN (explicit congestion
                     notification) bit.

              _p_a_c_k_e_t_S_i_z_e__
                     The size in bytes to use for all packets from this source.

              _t_c_p_i_p___b_a_s_e___h_d_r___s_i_z_e__
                     The size in bytes of the base TCP/IP header.

              _t_c_p_T_i_c_k__
                     The TCP clock granularity for measuring roundtrip times.  Note that it is set by default to the non-standard value of 100ms.  Measured in seconds.

              _b_u_g_F_i_x__
                     Set to true to remove a bug when multiple fast retransmits are allowed for packets dropped in a single window of data.

              _m_a_x_b_u_r_s_t__
                     Set to zero to ignore.  Otherwise, the maximum number of packets that the source can send in response to a single incoming ACK.

              _s_l_o_w___s_t_a_r_t___r_e_s_t_a_r_t__
                     Boolean; set to 1 to slow-start after the connection goes idle.  On by default.

              _s_r_t_t___i_n_i_t__
                     Initial value for the smoothed roundtrip time estimate.  Default is 0 seconds.

              _t___r_t_t_v_a_r__
                     Initial value for the variance in roundtrip time.  Default is 3 seconds.

              _r_t_x_c_u_r___i_n_i_t__
                     Initial value for the retransmit value.  Default is 6 seconds.

              _T___S_R_T_T___B_I_T_S
                     Exponent of weight for updating the smoothed round-trip time t_srtt_.  Default is 3, for a weight of 1/2^T_SRTT_BITS or 1/8.

              _T___R_T_T_V_A_R___B_I_T_S
                     Exponent of weight for updating variance in round-trip time, t_rttvar_.  Default is 2, for a weight of 1/2^T_RTTVAR_BITS or 1/4.

              _r_t_t_v_a_r___e_x_p__
                     Exponent of multiple of the mean deviation in calculating the current retransmit value t_rtxcur_.  Default is 2, for a multiple of 2^rttvar_exp_ or 4.

       DDeeffiinneedd CCoonnssttaannttss

              _M_W_S    The Maximum Window Size in packets for a TCP connection.  MWS determines the size of an array in tcp-sink.cc.  The default for MWS is 1024 packets.  For Tahoe TCP, the "window" parame‐
                     ter, representing the receiver's advertised window, should be less than MWS-1.  For Reno TCP, the "window" parameter should be less than (MWS-1)/2.

       SSttaattee VVaarriiaabblleess

              _d_u_p_a_c_k_s__
                     Number of duplicate acks seen since any new data was acknowledged.

              _s_e_q_n_o__ Highest sequence number for data from data source to TCP.

              _t___s_e_q_n_o__
                     Current transmit sequence number.

              _a_c_k__   Highest acknowledgment seen from receiver.

              _c_w_n_d__  Current value of the congestion window (in packets).

              _a_w_n_d__  Current value of a low-pass filtered version of the congestion window.  For investigations of different window-increase algorithms.

              _s_s_t_h_r_e_s_h__
                     Current value of the slow-start threshold (in packets).

              _r_t_t__   Round-trip time estimate.  In seconds (expressed in multiples of tcpTick_).

              _s_r_t_t__  Smoothed round-trip time estimate.  In seconds (in multiples of tcpTick_/8).

              _r_t_t_v_a_r__
                     Round-trip time mean deviation estimate.

              _t___r_t_x_c_u_r__
                     Current retransmit value.  In seconds.

              _b_a_c_k_o_f_f__
                     Round-trip time exponential backoff constant.


TTCCPP//RREENNOO OOBBJJEECCTTSS
       TCP/Reno objects are a subclass of TCP objects that implement the Reno TCP transport protocol as described in [7].  There are no methods, configuration parameters or state variables specific to this
       object.


TTCCPP//NNEEWWRREENNOO OOBBJJEECCTTSS
       TCP/Newreno objects are a subclass of TCP objects that implement a modified version of the BSD Reno TCP transport protocol.

       There are no methods or state variables specific to this object.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _n_e_w_r_e_n_o___c_h_a_n_g_e_s__
                     Set  to  zero  for the default NewReno described in [7].  Set to 1 for additional NewReno algorithms as suggested in [10]; this includes the estimation of the ssthresh parameter during
                     slow-start.


TTCCPP//VVEEGGAASS OOBBJJEECCTTSS
       This section of the man page has not yet been written.


TTCCPP//SSAACCKK11 OOBBJJEECCTTSS
       TCP/Sack1 objects are a subclass of TCP objects that implement the BSD Reno TCP transport protocol with Selective Acknowledgement Extensions as described in [7].

       They inherit all of the TCP object functionality.  There are no methods, configuration parameters or state variables specific to this object.


TTCCPP//FFAACCKK OOBBJJEECCTTSS
       TCP/Fack objects are a subclass of TCP objects that implement the BSD Reno TCP transport protocol with Forward Acknowledgement congestion control.

       They inherit all of the TCP object functionality.  There are no methods or state variables specific to this object.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _s_s_-_d_i_v_4
                     Overdamping algorithm. Divides ssthresh by 4 (instead of 2) if congestion is detected within 1/2 RTT of slow-start. (1=Enable, 0=Disable)

              _r_a_m_p_d_o_w_n
                     Rampdown data smoothing algorithm. Slowly reduces congestion window rather than instantly halving it. (1=Enable, 0=Disable)


TTCCPP//FFUULLLLTTCCPP OOBBJJEECCTTSS
       This section has not yet been added to the man page.  The implementation and the configuration parameters are described in [11].


TTCCPPSSIINNKK OOBBJJEECCTTSS
       TCPSink objects are a subclass of agent objects that implement a receiver for TCP packets.  The simulator only implements "one-way" TCP connections, where the TCP source sends data packets  and  the
       TCP sink sends ACK packets.  TCPSink objects inherit all of the generic agent functionality.  There are no methods or state variables specific to the TCPSink object.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _p_a_c_k_e_t_S_i_z_e__
                     The size in bytes to use for all acknowledgment packets.

              _m_a_x_S_a_c_k_B_l_o_c_k_s__
                     The  maximum  number  of blocks of data that can be acknowledged in a SACK option.  For a receiver that is also using the time stamp option [RFC 1323], the SACK option specified in RFC
                     2018 has room to include three SACK blocks.  This is only used by the TCPSink/Sack1 subclass.  This value may not be increased within any particular TCPSink object  after  that  object
                     has been allocated.  (Once a TCPSink object has been allocated, the value of this parameter may be decreased but not increased).


TTCCPPSSIINNKK//DDEELLAACCKK OOBBJJEECCTTSS
       DelAck  objects  are a subclass of TCPSink that implement a delayed-ACK receiver for TCP packets.  They inherit all of the TCPSink object functionality.  There are no methods or state variables spe‐
       cific to the DelAck object.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _i_n_t_e_r_v_a_l__
                     The amount of time to delay before generating an acknowledgment for a single packet.  If another packet arrives before this time expires, generate an acknowledgment immediately.


TTCCPPSSIINNKK//SSAACCKK11 OOBBJJEECCTTSS
       TCPSink/Sack1 objects are a subclass of TCPSink that implement a SACK receiver for TCP packets.  They inherit all of the TCPSink object functionality.  There are no methods, configuration parameters
       or state variables specific to this object.


TTCCPPSSIINNKK//SSAACCKK11//DDEELLAACCKK OOBBJJEECCTTSS
       TCPSink/Sack1/DelAck  objects are a subclass of TCPSink/Sack1 that implement a delayed-SACK receiver for TCP packets.  They inherit all of the TCPSink/Sack1 object functionality.  There are no meth‐
       ods or state variables specific to this object.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _i_n_t_e_r_v_a_l__
                     The amount of time to delay before generating an acknowledgment for a single packet.  If another packet arrives before this time expires, generate an acknowledgment immediately.


SSRRMM OOBBJJEECCTTSS
       SRM objects are a subclass of agent objects that implement the SRM reliable multicast transport protocol. They inherit all of the generic agent functionalities.

       $$ssrrmm ttrraaffffiicc--ssoouurrccee _s_o_u_r_c_e
              Attach a traffic source, e.g., Application/Traffic/CBR, to the SRM agent.

       $$ssrrmm ssttaarrtt
              Join the multicast group, start the SRM agent and its attached traffic source.

       $$ssrrmm ddeelleettee
              Stop the SRM agent, delete all its status and detach the traffic source.

       $$ssrrmm ttrraaccee _t_r_a_c_e_-_f_i_l_e
              Write the traces generated by the SRM agent to _t_r_a_c_e_-_f_i_l_e. The traces includes timer settings, request and repair sending and receipts, etc. Two related files that are not built into  ns  are
              _t_c_l_/_m_c_a_s_t_/_s_r_m_-_d_e_b_u_g_._t_c_l  that  permits more detailed tracing of the delay computation functions, and _t_c_l_/_m_c_a_s_t_/_s_r_m_-_n_a_m_._t_c_l that separately marks srm control messages from data.  The latter is
              useful to enhance nam visualisation.

       $$ssrrmm lloogg _l_o_g_-_f_i_l_e
              Write the recovery statistics during each request or repair to _l_o_g_-_f_i_l_e.  The statistics include start time, duration, message id, total number of duplicate requests and repairs.

       $$ssrrmm ddiissttaannccee?? _n_o_d_e
              Return the distance estimate to _n_o_d_e in this SRM agent.

       $$ssrrmm ddiissttaanncceess?? _n_o_d_e
              Returns a list of <group member,  distance> tuples of the distances to all group members that this node is aware of.  The group member is identified as the address of the remote  agent.   The
              first tuple is this agent's token.  The list can be directly loaded into a Tcl array.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _p_a_c_k_e_t_S_i_z_e__
                     The data packet size in bytes that will be used for repair messages. The default value is 1024.

              _r_e_q_u_e_s_t_F_u_n_c_t_i_o_n__
                     The  algorithm used to produce a retransmission request, e.g., setting request timers. The default value is SRM/request. Other possible request functions are SRM/request/Adaptive, used
                     by the Adaptive SRM code.

              _r_e_p_a_i_r_F_u_n_c_t_i_o_n__
                     The algorithm used to produce a repair, e.g., compute repair timers. The default value is SRM/repair. Other possible request functions are SRM/repair/Adaptive, used by the Adaptive SRM
                     code.

              _s_e_s_s_i_o_n_F_u_n_c_t_i_o_n__
                     The algorithm used to generate session messages. Default is SRM/session

              _s_e_s_s_i_o_n_D_e_l_a_y__
                     The  basic  interval  of  session messages. Slight random variation is added to this interval to avoid global synchronization of session messages. User may want to adjust this variable
                     according to their specific simulation.  Measured in seconds; default value is 1.0 seconds.

              _C_1___, _C_2__
                     The parameters which control the request timer. Refer to [8] for detail. The default value is _C_1__ = _C_2__ = 2.0.

              _D_1___, _D_2__
                     The parameters which control the repair timer. Refer to [8] for detail. The default value is _D_1__ = _D_2__ = 1.0.

              _r_e_q_u_e_s_t_B_a_c_k_o_f_f_L_i_m_i_t__
                     The maximum number of exponential backoffs. Default value is 5.

       SSttaattee VVaarriiaabblleess

              _s_t_a_t_s__ An array containing multiple statistics needed by adaptive SRM agent.  Including: duplicate requests and repairs in current request/repair period, average number of duplicate  requests
                     and repairs, request and repair delay in current request/repair period, average request and repair delay.


SSRRMM//AAddaappttiivvee OOBBJJEECCTTSS
       SRM/Adaptive objects are a subclass of the SRM objects that implement the adaptive SRM reliable multicast transport protocol. They inherit all of the SRM object functionalities.

       SSttaattee VVaarriiaabblleess Refer to the SRM paper by Sally et al ([11]) for more detail.

              _p_d_i_s_t_a_n_c_e__
                     This variable is used to pass the distance estimate provided by the remote agent in a request or repair message.

              _D_1___, _D_2__
                     The same as that in SRM agents, except that they are initialized to log10(group size) when generating the first repair.

              _M_i_n_C_1___, _M_a_x_C_1___, _M_i_n_C_2___, _M_a_x_C_2__
                     The minimum/maximum values of C1_ and C2_. Default initial values are defined in [8].  These values define the dynamic range of _C_1__ and _C_2__.

              _M_i_n_D_1___, _M_a_x_D_1___, _M_i_n_D_2___, _M_a_x_D_2__
                     The minimum/maximum values of D1_ and D2_. Default initial values are defined in [8]. These values define the dynamic range of _D_1__ and _D_2__.

              _A_v_e_D_u_p_s
                     Higher bound for average duplicates.

              _A_v_e_D_e_l_a_y
                     Higher bound for average delay.

              _e_p_s    _A_v_e_D_u_p_s - _d_u_p_s determines the lower bound of the number of duplicates, when we should adjust parameters to decrease delay.


AAPPPPLLIICCAATTIIOONN OOBBJJEECCTTSS
       Application objects generate data for transport agents to send.


FFTTPP AAPPPPLLIICCAATTIIOONN OOBBJJEECCTTSS
       Application/FTP objects  produce bulk data for a TCP object to send.

       $$ffttpp ssttaarrtt
              Causes FTP to produce packets indefinitely.

       $$ffttpp pprroodduuccee _n
              Causes the FTP object to produce _n packets instantaneously.

       $$ffttpp ssttoopp
              Causes the attached TCP object to stop sending data.

       $$ffttpp aattttaacchh _a_g_e_n_t
              Attaches an Application/FTP object to _a_g_e_n_t.

       $$ffttpp pprroodduucceemmoorree _c_o_u_n_t
              Causes the Application/FTP object to produce _c_o_u_n_t more packets.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _m_a_x_p_k_t_s
                     The maximum number of packets generated.


TTEELLNNEETT AAPPPPLLIICCAATTIIOONN OOBBJJEECCTTSS
       Application/Telnet  objects produce individual packets with inter-arrival times as follows.  If _i_n_t_e_r_v_a_l__ is non-zero, then inter-arrival times are chosen from an exponential distribution with aver‐
       age _i_n_t_e_r_v_a_l__.  If _i_n_t_e_r_v_a_l__ is zero, then inter-arrival times are chosen using the "tcplib" telnet distribution.


       $$tteellnneett ssttaarrtt
              Causes the Application/Telnet object to start producing packets.

       $$tteellnneett ssttoopp
              Causes the Application/Telnet object to stop producing packets.

       $$tteellnneett aattttaacchh _a_g_e_n_t
              Attaches a Application/Telnet object to _a_g_e_n_t.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _i_n_t_e_r_v_a_l__
                     The average inter-arrival time in seconds for packets generated by the Application/Telnet object.



TTRRAAFFFFIICC OOBBJJEECCTTSS
       Traffic objects create data for a transport protocol to send.  A Traffic object is created by instantiating an object of class Application/Traffic/_t_y_p_e where _t_y_p_e is one of Exponential, Pareto, CBR,
       Trace.


EEXXPPOONNEENNTTIIAALL TTRRAAFFFFIICC OOBBJJEECCTTSS
       Application/Traffic/Exponential  objects  generate  On/Off traffic.  During "on" periods, packets are generated at a constant burst rate.  During "off" periods, no traffic is generated.  Burst times
       and idle times are taken from exponential distributions.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _p_a_c_k_e_t___s_i_z_e__
                     The packet size in bytes.

              _b_u_r_s_t___t_i_m_e__
                     Burst duration in seconds.

              _i_d_l_e___t_i_m_e__
                     Idle time in seconds.

              _r_a_t_e__  Peak rate in bits per second.


PPAARREETTOO TTRRAAFFFFIICC OOBBJJEECCTTSS
       Application/Traffic/Pareto objects generate On/Off traffic with burst times and idle times taken from pareto distributions.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _p_a_c_k_e_t___s_i_z_e__
                     The packet size in bytes.

              _b_u_r_s_t___t_i_m_e__
                     Average on time in seconds.

              _i_d_l_e___t_i_m_e__
                     Average off time in seconds.

              _r_a_t_e__  Peak rate in bits per second.

              _s_h_a_p_e__ Pareto shape parameter.


CCBBRR ((CCOONNSSTTAANNTT BBIITT RRAATTEE)) TTRRAAFFFFIICC OOBBJJEECCTTSS
       Application/Traffic/CBR objects generate packets at a constant rate.  Dither can be added to the interarrival times by enabling the "random" flag.

       CCoonnffiigguurraattiioonn PPaarraammeetteerrss

              _r_a_t_e__  Peak rate in bits per second.

              _p_a_c_k_e_t___s_i_z_e__
                     The packet size in bytes.

              _r_a_n_d_o_m__
                     Flag that turns dithering on and off (default is off).

              _m_a_x_p_k_t_s__
                     Maximum number of packets to send.


TTRRAACCEE TTRRAAFFFFIICC OOBBJJEECCTTSS
       Application/Traffic/Trace objects are used to generate traffic from a trace file.

       $$ttrraaccee aattttaacchh--ttrraacceeffiillee _t_f_i_l_e
              Attach the Tracefile object _t_f_i_l_e to this trace.  The Tracefile object specifies the trace file from which the traffic data is to be read (see TRACEFILE OBJECTS section).   Multiple  Applica‐
              tion/Traffic/Trace objects can be attached to the same Tracefile object.  A random starting place within the Tracefile is chosen for each Application/Traffic/Trace object.

       There are no configuration parameters for this object.


TTRRAACCEEFFIILLEE OOBBJJEECCTTSS
       Tracefile objects are used to specify the trace file that is to be used for generating traffic (see TRAFFIC/TRACE OBJECTS section).  $tracefile is an instance of the Tracefile Object.

       $$ttrraacceeffiillee ffiilleennaammee _t_r_a_c_e_-_i_n_p_u_t
              Set the filename from which the traffic trace data is to be read to _t_r_a_c_e_-_i_n_p_u_t_.

       There are no configuration parameters for this object.  A trace file consists of any number of fixed length records.  Each record consists of 2 32 bit fields.  The first indicates the interval until
       the next packet is generated in microseconds.  The second indicates the length of the next packet in bytes.


TTRRAACCEE AANNDD MMOONNIITTOORRIINNGG MMEETTHHOODDSS
       [NOTE: This section has not been verified to be up-to-date with the release.]  Trace objects are used to generate event level capture logs typically to an output file.  Throughout this  section  $ns
       refers to a Simulator object, $agent refers to an Agent object.


       $$nnss ccrreeaattee--ttrraaccee _t_y_p_e _f_i_l_e_I_D _n_o_d_e_1 _n_o_d_e_2 _[_o_p_t_i_o_n_]
              Create  a  Trace object of type _t_y_p_e and attach the filehandle _f_i_l_e_I_D to it to monitor the queues between nodes _n_o_d_e_1 and _n_o_d_e_2_.  _t_y_p_e can be one of Enque, Deque, Drop.  Enque monitors packet
              arrival at a queue.  Deque monitors packet departure at a queue.  Drop monitors packet drops at a queue.  _f_i_l_e_I_D must be a file handle returned by the Tcl _o_p_e_n command and it must  have  been
              opened  for  writing.   If  _o_p_t_i_o_n  is  not specified, the command will instruct the created trace object to generate ns traces. If _o_p_t_i_o_n is """nam""" the new object will produce nam traces.
              Returns a handle to the trace object.


       $$nnss ddrroopp--ttrraaccee _n_o_d_e_1 _n_o_d_e_2 _t_r_a_c_e
              Remove trace object attached to the link between nodes _n_o_d_e_1 and _n_o_d_e_2 with _t_r_a_c_e as the object handle.


       $$nnss ttrraaccee--qquueeuuee _n_o_d_e_1 _n_o_d_e_2 _f_i_l_e_I_D
              Enable Enque, Deque and Drop tracing on the link between _n_o_d_e_1 and _n_o_d_e_2_.


       $$nnss nnaammttrraaccee--qquueeuuee _n_o_d_e_1 _n_o_d_e_2 _f_i_l_e_I_D
              Same function as $$nnss ttrraaccee--qquueeuuee, except it produces nam traces.


       $$nnss ttrraaccee--aallll _f_i_l_e_I_D
              Enable Enque, Deque, Drop Tracing on all the links in the topology created after this method is invoked.  Also enables the tracing of network dynamics.  _f_i_l_e_I_D must be a file handle  returned
              by the Tcl _o_p_e_n command and it must have been opened for writing.


       $$nnss nnaammttrraaccee--aallll _f_i_l_e_I_D
              Same function as $$nnss ttrraaccee--aallll, except it will produce all equivalent traces in nam format. In addition, calling this command _b_e_f_o_r_e the simulator starts to run will generate color configura‐
              tions (if any) and topology information needed by nam (nodes, links, queues). An example can be found at ns-2/tcl/ex/nam-example.tcl.


       $$nnss nnaammttrraaccee--ccoonnffiigg _f_i_l_e_I_D
              Assign a file to store nam configuration information, e.g., node/link/agents and some Simulator-related traces such as annotations.  When you don't want to trace every object. call this func‐
              tion  and  then  use _$_n_s _n_a_m_t_r_a_c_e_-_q_u_e_u_e, _r_t_M_o_d_e_l _t_r_a_c_e, etc., to insert traces individually. Note that you should use the same file for individual traces and nam configuration. An example for
              this is available at ns-2/tcl/ex/nam-separate-trace.tcl.


       $$nnss mmoonniittoorr--qquueeuuee _n_o_d_e_1 _n_o_d_e_2
              Arrange for queue length of link between nodes _n_o_d_e_1 and _n_o_d_e_2 to be tracked.  Returns QueueMonitor object that can be queried to learn average queue size etc.  [see QueueMonitor Objects sec‐
              tion]


       $$nnss fflluusshh--ttrraaccee
              Flush the output channels attached to all the trace objects.


       $$lliinnkk ttrraaccee--ddyynnaammiiccss _n_s _f_i_l_e_I_D _[_o_p_t_i_o_n_]
              Trace the dynamics of this link and write the output to _f_i_l_e_I_D filehandle.  _n_s is an instance of the Simulator or MultiSim object that was created to invoke the simulation.


       $$nnss ccoolloorr _i_d _n_a_m_e
              Create a color index, which links the number _i_d to the color name _n_a_m_e. All colors created _b_e_f_o_r_e the simulator starts to run will be written to nam trace file, if there is any.


       $$nnss ttrraaccee--aannnnoottaattee _s_t_r_i_n_g
              Writes an annotation to ns and nam trace file, if there are any. The string should be enclosed in double quote to make it a single argument.


       ttrraaccee__aannnnoottaattee _s_t_r_i_n_g
              Another version of $$nnss ttrraaccee--aannnnoottaattee, which is a global function and doesn't require the caller to know ns.


       $$nnss dduupplleexx--lliinnkk--oopp $$nnooddee11 $$nnooddee22 $$oopp $$aarrggss
              Perform a given operation _$_o_p on the given duplex link (_$_n_o_d_e_1, _$_n_o_d_e_2).  The following two operations may be used:
              orient         - Specify the nam orientation of the duplex link. Values can be
                          left, right, up, down, their mixture combined by '-' (e.g.,
                          left-down), and a number specifying the angle between the
                          link and the horizontal line.
              queuePos  - Construct a queue of the simplex link (_$_n_o_d_e_1,
                          _$_n_o_d_e_2) in nam, and specify the angle between the
                          horizontal line and the line along which the queued packets
                          will be displayed.


       $$nnss aadddd--aaggeenntt--ttrraaccee _a_g_e_n_t _n_a_m_e _[_f_i_l_e_I_D_]
              Write  a nam trace line, which will create a trace agent for _a_g_e_n_t when interpreted by nam. The trace agent's name will be _n_a_m_e. This nam trace agent is used to show the position of _a_g_e_n_t and
              can be used to write nam traces of variables associated with the agent.  By default traces will be written to the file assigned by _n_a_m_t_r_a_c_e_-_a_l_l.  _f_i_l_e_I_D can be used to write traces to another
              file.


       $$aaggeenntt ttrraacceevvaarr _n_a_m_e
              Label OTcl variable _n_a_m_e of $$aaggeenntt to be traced. Then whenever the variable _n_a_m_e changes value, a nam trace line will be written to nam trace file, if there is one. Note that _n_a_m_e must be the
              same as the variable's real OTcl name.


       $$nnss ddeelleettee--aaggeenntt--ttrraaccee _a_g_e_n_t
              Write a nam trace line, which will delete the nam trace associated with _a_g_e_n_t when interpreted by nam.


       $$aaggeenntt aadddd--vvaarr--ttrraaccee _n_a_m_e _v_a_l_u_e _[_t_y_p_e_]
              Write a nam trace line, which creates a variable trace with name _n_a_m_e and value _v_a_l_u_e, when interpreted by nam. _t_y_p_e indicates the type of the variable, e.g., is it a list, array, or a  plain
              variable. Currently only plain variable is supported, for which _t_y_p_e = 'v'.


       The following 2 functions should be called _a_f_t_e_r the simulator starts running. This can be done using $$nnss aatt.


       $$aaggeenntt ddeelleettee--vvaarr--ttrraaccee _n_a_m_e
              Write a nam trace line, which deletes the variable trace _n_a_m_e when interpreted by nam.


       $$aaggeenntt uuppddaattee--vvaarr--ttrraaccee _n_a_m_e _v_a_l_u_e _[_t_y_p_e_]
              Write  a  nam  trace  line,  which changes the value of traced variable _n_a_m_e when interpreted by nam. Unlike $$aaggeenntt ttrraacceevvaarr, the above 3 functions provide 'manual' variable tracing, in which
              variable tracing are done by placing $$aaggeenntt uuppddaattee--vvaarr--ttrraaccee in OTcl code, while _t_r_a_c_e_v_a_r automatically generates nam traces when the traced variable changes value.


       The tracefile format is backward compatible with the output files in the ns version 1 simulator so that ns-1 post-processing scripts can still be used.  Trace records of  traffic  for  link  objects
       with Enque, Deque or Drop Tracing have the following form:

                  <code> <time> <hsrc> <hdst> <packet>

       where

              <code> := [hd+-r] h=hop d=drop +=enque -=deque r=receive
              <time> := simulation time in seconds
              <hsrc> := first node address of hop/queuing link
              <hdst> := second node address of hop/queuing link
              <packet> :=  <type> <size> <flags> <flowID> <src.sport> <dst.dport> <seq> <pktID>
              <type> := tcp|telnet|cbr|ack etc.
              <size> := packet size in bytes
              <flags> := [CP]  C=congestion, P=priority
              <flowID> := flow identifier field as defined for IPv6
              <src.sport> := transport address (src=node,sport=agent)
              <dst.sport> := transport address (dst=node,dport=agent)
              <seq> := packet sequence number
              <pktID> := unique identifer for every new packet

              Only those agents interested in providing sequencing will generate sequence numbers and hence this field may not be useful for packets generated by some agents.


              For links that use RED gateways, there are additional trace records as follows:

                         <code> <time> <value>

              where

                     <code> := [Qap] Q=queue size, a=average queue size,
                          p=packet dropping probability
                     <time> := simulation time in seconds
                     <value> := value


              Trace records for link dynamics are of the form:

                         <code> <time> <state> <src> <dst>

              where

                     <code> := [v]
                     <time> := simulation time in seconds
                     <state> := [link-up | link-down]
                     <src> := first node address of link
                     <dst> := second node address of link


IINNTTEEGGRRAATTOORR OObbjjeeccttss
       Integrator  Objects  support  the approximate computation of continuous integrals using discrete sums.  The running sum(integral) is computed as: sum_ +=  [lasty_ * (x - lastx_)] where (x, y) is the
       last element entered and (lastx_, lasty_) was the element previous to that added to the sum.  lastx_ and lasty_ are updated as new elements are added.  The first sample point defaults to (0,0)  that
       can be changed by changing the values of (lastx_,lasty_).

       $$iinntteeggrraattoorr nneewwppooiinntt _x _y
              Add the point (x,y) to the sum.  Note that it does not make sense for x to be less than lastx_.

       There are no configuration parameters specific to this object.

       SSttaattee VVaarriiaabblleess

              _l_a_s_t_x__ x-coordinate of the last sample point.

              _l_a_s_t_y__ y-coordinate of the last sample point.

              _s_u_m__   Running sum (i.e. the integral) of the sample points.


SSAAMMPPLLEESS OObbjjeeccttss
       Samples Objects support the computation of mean and variance statistics for a given sample.

       $$ssaammpplleess mmeeaann
              Returns mean of the sample.

       $$ssaammpplleess vvaarriiaannccee
              Returns variance of the sample.

       $$ssaammpplleess ccnntt
              Returns a count of the sample points considered.

       $$ssaammpplleess rreesseett
              Reset the Samples object to monitor a fresh set of samples.

       There are no configuration parameters or state variables specific to this object.


BBUUIILLTTIINNSS
       [NOTE:  This  section has not been verified to be up-to-date with the release.]  Because _O_T_c_l is a full-fledged programming language, it is easy to build high-level simulation constructs from the ns
       primitives.  Several library routines have been built in this way, and are embedded into the ns interpreter as methods of the Simulator class.  Throughout this section  $ns  represents  a  Simulator
       object.

       $$nnss ccrreeaattee--ccoonnnneeccttiioonn _s_r_c_T_y_p_e _s_r_c_N_o_d_e _d_s_t_T_y_p_e _d_s_t_N_o_d_e _c_l_a_s_s
              Create  a  source  agent  of type _s_r_c_T_y_p_e at node _s_r_c_N_o_d_e and connect it to a destination agent of type _d_s_t_T_y_p_e at node _d_s_t_N_o_d_e_.  Also, connect the destination agent to the source agent.  The
              traffic class of both agents is set to _c_l_a_s_s_.  This method returns the source agent.


EEXXAAMMPPLLEE
           set ns [new Simulator]

           #
           # Create two nodes
           #
           set n0 [$ns node]
           set n1 [$ns node]

           #
           # Create a trace and arrange for all the trace events of the
           # links subsequently created to be dumped to "out.tr"
           #
           set f [open out.tr w]
           $ns trace-all $f

           #
           # Connect the two nodes with a 1.5Mb link with a transmission
           # delay of 10ms using FIFO drop-tail queuing
           #
           $ns duplex-link $n0 $n1 1.5Mb 10ms DropTail

           #
           # Set up BSD Tahoe TCP connections in opposite directions.
           #
           set tcp_src1 [new Agent/TCP]
           set tcp_snk1 [new Agent/TCPSink]
           set tcp_src2 [new Agent/TCP]
           set tcp_snk2 [new Agent/TCPSink]
           $ns attach-agent $n0 $tcp_src1
           $ns attach-agent $n1 $tcp_snk1
           $ns attach-agent $n1 $tcp_src2
           $ns attach-agent $n0 $tcp_snk2
           $ns connect $tcp_src1 $tcp_snk1
           $ns connect $tcp_src2 $tcp_snk2

           #
           # Create ftp sources at the each node
           #
           set ftp1 [$tcp_src1 attach-source FTP]
           set ftp2 [$tcp_src2 attach-source FTP]

           #
           # Start up the first ftp at the time 0 and
           # the second ftp staggered 1 second later
           #

           $ns at 0.0 "$ftp1 start"
           $ns at 1.0 "$ftp2 start"

           #
           # run the simulation for 10 simulated seconds
           #
           $ns at 10.0 "exit 0"
           $ns run


DDEEBBUUGGGGIINNGG
       To enable debugging when building ns from source:
           % ./configure --enable-debug
           % make

       For more details about ns debugging please see <http://www-mash.cs.berkeley.edu/ns/ns-debugging.html>.


DDIIFFFFEERREENNCCEESS FFRROOMM NNSS--11
       In general, more complex objects in ns-1 have been broken down into simpler components for greater flexibility and composability.  Details of differences between  ns-1  and  ns-2  can  be  found  at
       <http://www-mash.cs.berkeley.edu/ns/ns.html>.


HHIISSTTOORRYY
       Work  on  the  LBL Network Simulator began in May 1990 with modifications to S. Keshav's (keshav@research.att.com) REAL network simulator, which he developed for his Ph.D. work at U.C. Berkeley.  In
       Summer 1991, the simulation description language was revamped, and later, the NEST threads model was replaced with an event driven framework and an efficient scheduler.  Among  other  contributions,
       Sugih  Jamin  (jamin@usc.edu)  contributed  the  calendar-queue  based  scheduling code to this version of the program, which was known as _t_c_p_s_i_m_.  In December 1994, McCanne ported tcpsim to C++ and
       replaced the yacc-based simulation description language with a Tcl interface, and added preliminary multicast support.  Also at this time, the name changed  from  _t_c_p_s_i_m  to  the  more  generic  _n_s_.
       Throughout,  Floyd  has  made modifications to the TCP code and added additional source models for her investigations into RED gateways, resource management, class-based queuing, explicit congestion
       notification, and traffic phase effects.  Many of the papers discussing these issues are available through URL http://www-nrg.ee.lbl.gov/.


SSEEEE AALLSSOO
       Tcl(1), tclsh(1), nam(1), otclsh


       [[11]]    S. Keshav, ``REAL: A Network Simulator''.  UCB CS Tech Report 88/472, December 1988.  See http://minnie.cs.adfa.oz.au/REAL/index.html for more information.

       [[22]]    Floyd, S. and Jacobson, V.  Random Early Detection gateways for Congestion Avoidance.  IEEE/ACM Transactions on Networking, Vol.  1,  No.  4.   August  1993.   pp.  397-413.   Available  from
              http://www-nrg.ee.lbl.gov/floyd/red.html.

       [[33]]    Floyd, S.  Simulator Tests.  July 1995.  URL ftp://ftp.ee.lbl.gov/papers/simtests.ps.Z.

       [[44]]    Floyd, S., and Jacobson, V.  On Traffic Phase Effects in Packet-Switched Gateways.  Internetworking: Research and Experience, V.3 N.3, September 1992.  pp. 115-156.

       [[55]]    Floyd, S., and Jacobson, V.  Link-sharing and Resource Management Models for Packet Networks.  IEEE/ACM Transactions on Networking, Vol. 3 No. 4, August 1995.  pp. 365-386.

       [[66]]    Floyd, S., Notes of Class-Based Queueing: Setting Parameters.  URL ftp://ftp.ee.lbl.gov/papers/ params.ps.Z.  September 1995.

       [[77]]    Fall, K., and Floyd, S.  Comparisons of Tahoe, Reno, and Sack TCP.  December 1995.  URL ftp:// ftp.ee.lbl.gov/papers/sacks.ps.Z.

       [[88]]    David  Wetherall  and Christopher J. Linblad.  Extending Tcl for Dynamic Object-Oriented Programming.  In Proceedings of the USENIX Tcl/Tk Workshop, Toronto, Ontario, USENIX.  July, 1995.  At
              <http://www.tns.lcs.mit.edu/publications/tcltk95.djw.html>.

       [[99]]    M. Shreedhar and G. Varghese. Efficient Fair Queueing Using Deficit Round Robin. In Proc. of SIGCOMM, pp. 231-242, 1995.

       [[1100]]   Hoe, J., Improving the Start-up Behavior of a Congestion Control Scheme for TCP.  in SIGCOMM 96, August 1996, pp. 270-280.  URL http://www.acm.org/sigcomm/sigcomm96/papers/hoe.html.

       [[1111]]   Fall, K., Floyd, S., and Henderson, T., Ns Simulator Tests for Reno FullTCP.  URL ftp://ftp.ee.lbl.gov/papers/fulltcp.ps.  July 1997.

       [[1122]]   Floyd, S., Jacobson, V., Liu, C.-G., McCanne, S. and Zhang, L., A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing. To appear in  IEEE/ACK  Transaction  on
              Networking, November 1996.  ftp://ftp.ee.lbl.gov/papers/srm1.ps.gz

       [[1133]]   Fall, K., and Varadhan, K., (eds.), "Ns notes and documentation", work in progress.  http://www-mash.cs.berkeley.edu/ns/nsDoc.ps.gz

       Research using ns is on-going.  A list of recent research contributions employing ns can be found at <http://www-mash.cs.berkeley.edu/ns/ns-research.html>.

       Work on ns is on-going.  Information about the most recent version is available at <http://www-mash.cs.berkeley.edu/ns/ns.html>.

       A  mailing  list  for  ns users and announcements is also available, send mail to ns-users-request@mash.cs.berkeley.edu or ns-announce-request@mash.cs.berkeley.edu to join.  Questions should be for‐
       warded to ns-users; ns-announce will be low-traffic announcements only.


AAUUTTHHOORRSS
       Steven McCanne (mccanne@ee.lbl.gov), University of California, Berkeley and Lawrence Berkeley National Laboratory, Berkeley, CA, and Sally Floyd (floyd@ee.lbl.gov) Lawrence Berkeley National Labora‐
       tory, Berkeley, CA.  A complete list of contributors to ns is at <http://www-mash.cs.berkeley.edu/ns/ns-contributors.html>.

BBUUGGSS
       Not all of the functionality supported in ns-1 has been ported to ns-2.

       This manual page is incomplete.





                                                                                                 25 July 1997                                                                                           NS(1)
